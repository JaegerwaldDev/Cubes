<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Cubes</title>
    <style>
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        overflow: hidden;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      }
      .view {
        overflow: hidden;
        background-color: #808080;
        touch-action: none;
        user-select: none;
        height: 100dvh;
      }
      .world {
        position: absolute;
        left: 50%;
        top: 50%;
        transform-origin: 0 0;
        translate: 0 0;
        scale: 1;
        transition: scale 200ms;
      }
      .cube {
        --x: 0;
        --y: 0;
        --z: 0;
        position: absolute;
        width: 100px;
        height: 100px;
        background-color: #f00;
        background-image: conic-gradient(from -63.43deg at center, #0000 0deg 126.86deg, #0004 126.86deg 243.43deg, #0002 243.43deg 360deg);
        left: calc((var(--x) - var(--z)) * 50px);
        top: calc((var(--x) + var(--z)) * 25px - var(--y) * 50px);
        margin-left: -50px;
        margin-top: -50px;
        z-index: calc(var(--x) + var(--y) + var(--z));
        clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
        transition: filter 200ms, scale 100ms;
      }
      .cube:hover {
        filter: brightness(0.75);
        scale: 1.1;
      }
      .cube:active {
        filter: brightness(0.5);
        scale: 0.9;
      }
      .cube.placing {
        animation: cube-place 100ms ease-in-out;
      }
      .cube.breaking {
        animation: cube-break 150ms ease-out forwards;
        pointer-events: none;
      }

      .world.rot-0 .cube {
        left: calc((var(--x) - var(--z)) * 50px);
        top: calc((var(--x) + var(--z)) * 25px - var(--y) * 50px);
        z-index: calc(var(--x) + var(--y) + var(--z));
      }
      .world.rot-90 .cube {
        left: calc((var(--z) * -1 - var(--x)) * 50px);
        top: calc((var(--z) * -1 + var(--x)) * 25px - var(--y) * 50px);
        z-index: calc(var(--x) + var(--y) + var(--z) * -1);
      }
      .world.rot-180 .cube {
        left: calc((var(--x) * -1 - var(--z) * -1) * 50px);
        top: calc((var(--x) * -1 + var(--z) * -1) * 25px - var(--y) * 50px);
        z-index: calc(var(--x) * -1 + var(--y) + var(--z) * -1);
      }
      .world.rot-270 .cube {
        left: calc((var(--z) - var(--x) * -1) * 50px);
        top: calc((var(--z) + var(--x) * -1) * 25px - var(--y) * 50px);
        z-index: calc(var(--x) * -1 + var(--y) + var(--z));
      }

      @keyframes cube-place {
        from {
          scale: 0;
          opacity: 0;
        }
      }
      @keyframes cube-break {
        to {
          scale: 1.5;
          opacity: 0;
        }
      }

      .hud {
        position: fixed;
        padding: 1em;
        width: 100%;
        display: flex;
        flex-wrap: wrap;
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
        align-content: flex-start;
      }

      button {
        font-size: 1em;
      }

      .save-load {
        float: right;
      }
    </style>
  </head>
  <body>
    <div class="view">
      <div class="world"></div>
      <div class="hud">
        <input type="color" class="color-picker" value="#ff0000" />
        <input type="range" class="rotator" min="0" value="0" step="90" max="270" />
        <div class="save-load">
          <button type="button" class="btn-save">Save</button>
          <button type="button" class="btn-load" onclick="file.click()">load<input type="file" hidden id="file" class="load-file" /></button>
        </div>
      </div>
    </div>
    <script>
      const view = document.getElementsByClassName("view")[0];
      const world = document.getElementsByClassName("world")[0];
      const colorPicker = document.getElementsByClassName("color-picker")[0];
      const rotator = document.getElementsByClassName("rotator")[0];
      const saveBtn = document.getElementsByClassName("btn-save")[0];
      const loadBtn = document.getElementsByClassName("btn-load")[0];
      const loadFile = document.getElementsByClassName("load-file")[0];

      let currColor = "#ff0000";
      let isPanning = false;
      let rot = 0;
      let panX = 0;
      let panY = 0;
      let zoom = 1;
      let history = [];
      let historyIndex = 0;

      function getCubes() {
        return document.querySelectorAll(".cube:not(.breaking)");
      }

      function angleFromPoints(x1, y1, x2, y2) {
        return Math.atan2(y2 - y1, x2 - x1);
      }

      function worldCoords(screenX, screenY) {
        const worldX = Math.round(((screenX - (innerWidth / 2 + panX * zoom)) / (50 * zoom) + (screenY - (innerHeight / 2 + panY * zoom)) / (25 * zoom)) / 2);
        const worldZ = Math.round(((screenY - (innerHeight / 2 + panY * zoom)) / (25 * zoom) - (screenX - (innerWidth / 2 + panX * zoom)) / (50 * zoom)) / 2);
        if (rot === 0) return { x: worldX, z: worldZ };
        else if (rot === 90) return { x: worldZ, z: worldX * -1 };
        else if (rot === 180) return { x: worldX * -1, z: worldZ * -1 };
        else if (rot === 270) return { x: worldZ * -1, z: worldX };
      }

      function getCubeAt(x, y, z) {
        const cubes = getCubes();
        for (const cube of cubes) {
          if (cube.style.getPropertyValue("--x") == x && cube.style.getPropertyValue("--y") == y && cube.style.getPropertyValue("--z") == z) {
            return cube;
          }
        }
      }

      function serialize() {
        let frags = [];
        const cubes = getCubes();
        for (const cube of cubes) {
          frags.push(
            [cube.style.getPropertyValue("--x"), cube.style.getPropertyValue("--y"), cube.style.getPropertyValue("--z"), cube.style.backgroundColor].join("/")
          );
        }
        return frags.join("|");
      }

      function deserialize(string) {
        string.split("|").forEach((c, i) => setTimeout(() => placeCube(...c.split("/")), 25 * i));
      }

      function clear() {
        for (const cube of getCubes()) {
          breakCube(cube);
        }
      }

      function save() {
        const a = document.createElement("a");
        a.setAttribute("href", "data:text/plain;charset=utf-8," + encodeURIComponent(serialize()));
        a.setAttribute("download", "cubes.cubes");
        a.style.display = "none";
        document.body.appendChild(a);
        a.click();
        a.remove();
      }

      function load(file) {
        if (file) {
          const reader = new FileReader();
          reader.readAsText(file, "UTF-8");
          reader.onload = (e) => {
            clear();
            deserialize(e.target.result);
          };
          reader.onerror = (e) => {
            alert("Error reading file.\nError : " + e.target.error);
          };
        }
      }
      function addHistory() {
        if (historyIndex > 0) {
          history.length -= historyIndex;
          historyIndex = 0;
        }
        history.push(getCubes());
      }

      function getHistory() {
        return history[history.length - historyIndex - 1];
      }

      function putCubes(cubes) {
        world.replaceChildren(...cubes);
      }

      world.classList.contains("");

      function putHistory() {
        putCubes(getHistory());
      }

      function undo(steps = 1) {
        if (history.length > historyIndex + steps) {
          historyIndex += steps;
          putHistory();
        }
      }
      function redo(steps = 1) {
        if (historyIndex >= steps) {
          historyIndex -= steps;
          putHistory();
        }
      }

      function reorganize() {
        let cubes = getCubes().entries();
        cubes.sort((a, b) => {
          a.style.getPropertyValue("--x") + a.style.getPropertyValue("--y") + a.style.getPropertyValue("--z");
        });
      }

      function placeCube(x, y, z, color = currColor) {
        if (!getCubeAt(x, y, z)) {
          const cube = document.createElement("div");
          cube.className = "cube placing";
          cube.style.setProperty("--x", x);
          cube.style.setProperty("--y", y);
          cube.style.setProperty("--z", z);
          cube.style.backgroundColor = color;
          cube.addEventListener("pointerdown", (e) => {
            if (e.button == 0) {
              const angle = angleFromPoints(50, 50, e.offsetX, e.offsetY);
              let newX = 0;
              let newY = 0;
              let newZ = 0;
              if (angle > -2.67785867 && angle < -0.46373398) newY++; //
              else if (angle > -0.46373398 && angle < 1.5708) newX++; // Unintentionally equal line widths lol
              else if (angle > 1.5708 || angle < -2.67785867) newZ++; //
              if (rot === 0) placeCube(x + newX, y + newY, z + newZ);
              else if (rot === 90) placeCube(x + newZ, y + newY, z + newX * -1);
              else if (rot === 180) placeCube(x + newX * -1, y + newY, z + newZ * -1);
              else if (rot === 270) placeCube(x + newZ * -1, y + newY, z + newX);
            } else if (e.button == 2) {
              breakCube(cube);
            } else if (e.button == 1) {
              colorPicker.value = currColor = color;
            }
          });
          world.appendChild(cube);
          addHistory();
          setTimeout(() => cube.classList.remove("placing"), 100);
          console.log("Placed a cube at ", x, y, z, " with color ", color);
        }
      }

      function breakCube(cube) {
        cube.classList.add("breaking");
        setTimeout(() => {
          cube.classList.remove("breaking");
          cube.remove();
        }, 150);
        addHistory();
      }

      function pan(x, y) {
        panX += x / zoom;
        panY += y / zoom;
        world.style.setProperty("transform-origin", -panX + "px " + -panY + "px");
        world.style.setProperty("translate", panX + "px " + panY + "px");
      }

      function rotate(angle) {
        rot = Math.round(angle / 90) * 90;
        if (rot >= 360) rot -= Math.floor(rot / 360) * 360;
        world.className = `world rot-${rot}`;
        return rot;
      }

      view.addEventListener("pointerdown", (e) => {
        if (e.target === view) {
          isPanning = true;
        }
      });
      view.addEventListener("pointermove", (e) => {
        if (isPanning) {
          pan(e.movementX, e.movementY);
        }
      });
      view.addEventListener("pointerup", (e) => {
        isPanning = false;
        if (e.button == 0 && e.target === view) {
          const worldPos = worldCoords(e.clientX, e.clientY);
          placeCube(worldPos.x, 0, worldPos.z);
        }
      });

      view.addEventListener("wheel", (e) => {
        zoom *= 1 + e.deltaY * -0.005;
        zoom = Math.round(zoom * 10) / 10;
        if (zoom < 0.1) zoom = 0.1;
        else if (zoom > 10) zoom = 10;
        else pan((e.clientX - innerWidth / 2) * -0.1 * zoom, (e.clientY - innerHeight / 2) * -0.1 * zoom);
        world.style.scale = zoom;
      });

      view.addEventListener("contextmenu", (e) => e.preventDefault());

      rotator.addEventListener("input", (e) => rotate(rotator.value));

      colorPicker.addEventListener("input", (e) => (currColor = colorPicker.value));
      saveBtn.addEventListener("click", save);
      loadFile.addEventListener("input", (e) => load(loadFile.files[0]));
      loadFile.addEventListener("click", () => (loadFile.value = null));

      document.addEventListener("keydown", (e) => {
        if (e.code === "KeyZ" && e.ctrlKey) {
          e.preventDefault();
          undo();
        }
        if (e.code === "KeyY" && e.ctrlKey) {
          e.preventDefault();
          redo();
        }
      });

      placeCube(0, 0, 0);
    </script>
  </body>
</html>
